# 如何避免影分身代码

本文档提供实用指南，帮助开发者避免创建影分身代码（代码重复）。

---

## 什么是影分身代码？

**影分身代码**是指通过复制粘贴创建的重复代码。就像忍者的影分身术一样，看起来一样但存在于多个位置。

### 常见的影分身代码形式

1. **重复的类定义** - 相同或相似的类在多处定义
2. **重复的方法实现** - 相同逻辑的方法在多个类中重复
3. **重复的数据结构** - 相同的 DTO、实体或配置对象
4. **复制的业务逻辑** - 相同的算法或验证逻辑
5. **重复的测试代码** - 测试设置和断言逻辑的重复

---

## 为什么要避免影分身代码？

### 维护成本高
- 修改一处需要同步修改多处
- 容易遗漏某些副本
- 增加 bug 风险

### 理解困难
- 不清楚哪个是"真正"的实现
- 多个版本可能不一致
- 新人难以理解代码意图

### 测试困难
- 需要对所有副本进行测试
- 测试覆盖率误导
- 回归测试成本高

### 代码膨胀
- 不必要地增加代码量
- 影响构建和部署时间
- 增加代码审查负担

---

## 检测影分身代码

### 自动检测工具

运行影分身检测脚本：
```bash
./scripts/detect-shadow-clones.sh
```

### 手动检测方法

1. **搜索相似的类名**
```bash
find . -name "*.cs" | xargs grep "^public class" | sort | uniq -c | grep -v "^ *1 "
```

2. **搜索相似的方法名**
```bash
find . -name "*.cs" | xargs grep "public.*Async\|public.*void" | sort | uniq -c | grep -v "^ *1 "
```

3. **查找 TODO 关于重复代码的注释**
```bash
grep -r "重复\|duplicate\|copy" --include="*.cs" .
```

---

## 避免影分身代码的最佳实践

### 1. 在复制之前先思考

**问自己**：
- ❓ 我真的需要复制这段代码吗？
- ❓ 能否提取成共享方法？
- ❓ 能否使用继承或组合？
- ❓ 能否使用泛型或接口？

**原则**: **DRY (Don't Repeat Yourself)** - 不要重复自己

### 2. 重构而不是复制

#### 示例：提取共享方法

**❌ 错误（影分身）**:
```csharp
// ClassA.cs
public void ProcessOrderA()
{
    if (order.Id <= 0)
        throw new ArgumentException("Order ID must be positive");
    
    if (string.IsNullOrEmpty(order.Name))
        throw new ArgumentException("Order name is required");
    
    // ... processing logic
}

// ClassB.cs  
public void ProcessOrderB()
{
    if (order.Id <= 0)
        throw new ArgumentException("Order ID must be positive");
    
    if (string.IsNullOrEmpty(order.Name))
        throw new ArgumentException("Order name is required");
    
    // ... processing logic
}
```

**✅ 正确（重构）**:
```csharp
// OrderValidator.cs (共享)
public static class OrderValidator
{
    public static void Validate(Order order)
    {
        if (order.Id <= 0)
            throw new ArgumentException("Order ID must be positive");
        
        if (string.IsNullOrEmpty(order.Name))
            throw new ArgumentException("Order name is required");
    }
}

// ClassA.cs
public void ProcessOrder()
{
    OrderValidator.Validate(order);
    // ... processing logic
}

// ClassB.cs
public void ProcessOrder()
{
    OrderValidator.Validate(order);
    // ... processing logic
}
```

### 3. 使用继承提取公共行为

**❌ 错误（影分身）**:
```csharp
public class VendorADriver
{
    public async Task ConnectAsync()
    {
        // 连接重试逻辑
        for (int i = 0; i < MaxRetries; i++)
        {
            try
            {
                await DoConnectAsync();
                return;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Connection failed");
                await Task.Delay(CalculateBackoff(i));
            }
        }
    }
}

public class VendorBDriver
{
    public async Task ConnectAsync()
    {
        // 相同的连接重试逻辑
        for (int i = 0; i < MaxRetries; i++)
        {
            // ... 完全相同的实现
        }
    }
}
```

**✅ 正确（使用基类）**:
```csharp
public abstract class DriverBase
{
    protected abstract Task DoConnectAsync();
    
    public async Task ConnectAsync()
    {
        // 通用连接重试逻辑
        for (int i = 0; i < MaxRetries; i++)
        {
            try
            {
                await DoConnectAsync();
                return;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Connection failed");
                await Task.Delay(CalculateBackoff(i));
            }
        }
    }
}

public class VendorADriver : DriverBase
{
    protected override Task DoConnectAsync()
    {
        // 只实现厂商特定逻辑
    }
}

public class VendorBDriver : DriverBase
{
    protected override Task DoConnectAsync()
    {
        // 只实现厂商特定逻辑
    }
}
```

### 4. 统一类型定义位置

#### DTO 定义规范

**规则**: 所有 DTO 必须定义在 `Contracts` 层

**❌ 错误**:
```
Observability/Events/ParcelDto.cs
Host.Contracts/ParcelDto.cs
```

**✅ 正确**:
```
Contracts/ZakYip.NarrowBeltDiverterSorter.Contracts/ParcelDto.cs
```

#### 事件参数定义规范

**规则**: 所有 EventArgs 必须定义在 `Core` 或 `Contracts` 层

**❌ 错误**:
```
Observability/Events/ParcelCreatedEventArgs.cs
Execution/Events/ParcelCreatedEventArgs.cs
```

**✅ 正确**:
```
Core/Domain/Events/ParcelCreatedEventArgs.cs
```

### 5. 使用泛型减少重复

**❌ 错误（影分身）**:
```csharp
public class ParcelRepository
{
    public async Task<Parcel?> GetByIdAsync(long id)
    {
        return await _db.FindAsync<Parcel>(id);
    }
}

public class ChuteRepository
{
    public async Task<Chute?> GetByIdAsync(long id)
    {
        return await _db.FindAsync<Chute>(id);
    }
}
```

**✅ 正确（使用泛型）**:
```csharp
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(long id);
}

public class Repository<T> : IRepository<T> where T : class
{
    public async Task<T?> GetByIdAsync(long id)
    {
        return await _db.FindAsync<T>(id);
    }
}
```

### 6. 使用组合而非复制

**❌ 错误（影分身）**:
```csharp
public class ServiceA
{
    // 日志逻辑
    private void LogOperation(string operation)
    {
        _logger.LogInformation($"[{DateTime.Now}] {operation}");
    }
}

public class ServiceB
{
    // 相同的日志逻辑
    private void LogOperation(string operation)
    {
        _logger.LogInformation($"[{DateTime.Now}] {operation}");
    }
}
```

**✅ 正确（使用组合）**:
```csharp
public class OperationLogger
{
    public void Log(string operation)
    {
        _logger.LogInformation($"[{DateTime.Now}] {operation}");
    }
}

public class ServiceA
{
    private readonly OperationLogger _operationLogger;
    
    public ServiceA(OperationLogger logger)
    {
        _operationLogger = logger;
    }
    
    public void DoWork()
    {
        _operationLogger.Log("ServiceA work");
    }
}
```

---

## 重构现有影分身代码

### 步骤

1. **识别重复代码**
   ```bash
   ./scripts/detect-shadow-clones.sh
   ```

2. **记录技术债务**
   - 在 `docs/Conventions/技术债务.md` 中创建条目
   - 分配技术债务编号（TD-CLONE-NNN）
   - 设置优先级

3. **制定重构计划**
   - 确定规范实现位置
   - 评估影响范围
   - 计划测试策略

4. **执行重构**
   - 提取共享代码
   - 更新所有引用
   - 运行测试验证

5. **清理和验证**
   - 删除重复代码
   - 更新文档
   - 运行影分身检测确认

6. **更新技术债务文档**
   - 标记债务为"已解决"
   - 记录解决日期和 PR

---

## PR 检查清单

提交 PR 前，确保：

- [ ] 运行了 `./scripts/detect-shadow-clones.sh`
- [ ] 没有引入新的重复类定义
- [ ] 没有引入重复的事件参数
- [ ] 没有引入重复的 DTO
- [ ] 重复逻辑已提取到共享方法
- [ ] 已通读技术债务文档
- [ ] 新增技术债务已记录（如有）
- [ ] PR 描述说明了技术债务变更

---

## 工具和资源

### 检测工具
- `./scripts/detect-shadow-clones.sh` - 影分身检测脚本
- `./check-pr.sh` - PR 检查脚本

### 文档
- [技术债务文档](技术债务.md) - 技术债务管理
- [影分身代码审查报告](../implementation-summaries/影分身代码审查报告.md) - 当前状态
- [项目规则集](项目规则集.md) - 完整规则

### IDE 工具
- ReSharper - 代码重复检测
- SonarLint - 代码质量检查
- Visual Studio - "查找相似代码" 功能

---

## 总结

**记住**: 
1. 🚫 **不要复制粘贴代码**
2. 🔍 **在复制前先思考**
3. 🔨 **重构而不是复制**
4. 📝 **记录技术债务**
5. ✅ **使用自动化检测**

**口号**: "一个真相，多处引用；杜绝影分身，拥抱 DRY 原则！"

---

**版本**: v1.0  
**最后更新**: 2025-12-06  
**维护者**: ZakYip Team
